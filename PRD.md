# The Prompt Battle: Comprehensive Application Specification

This document outlines the complete specifications for "The Prompt Battle" - a web application for hosting and participating in Generative AI Image Prompt Battles using React, Vite, TypeScript, and Firebase Realtime Database.

## What is a Prompt Battle?

A Prompt Battle is a live competitive event where participants compete against each other using text-to-image AI software. Contestants create text prompts that generate images using AI models like DALL-E, Stable Diffusion, or Midjourney. The audience or a panel of judges then selects winners based on who created the most surprising, beautiful, or creative AI-generated images.

Originally developed by Florian A. Schmidt and Sebastian Schmieg with design students from HTW Dresden in 2022, Prompt Battles have evolved into various formats and are held at universities, art institutions, and tech events worldwide.

## Project Overview

The Prompt Battle application is a web-based platform that facilitates real-time prompt battles accessible on both desktop and mobile browsers. The application allows users to either host a battle or join existing battles as contestants or spectators. Hosts configure battle settings and coordinate the event, contestants submit prompts for image generation, and spectators vote for their favorite generated images.

The application will leverage OpenAI's GPT to generate topics for each round. The host's frontend application will directly use their OpenAI API key to generate images from contestant prompts, without requiring a separate backend server. The entire platform will operate in real-time using Firebase Realtime Database, providing instant updates to all participants.

## User Roles and Permissions

### Host
- Creates and configures battle settings
- Provides their own OpenAI API key (stored only in their frontend application)
- Starts/ends rounds and manages the flow of the event
- Can manually override voting results
- Has access to all administrative functions
- Can disable spectator voting for physical events

### Contestant
- Joins existing battles using a battle code
- Creates and submits prompts based on given topics
- Views all generated images
- May participate in voting (if enabled by host)

### Spectator
- Joins existing battles using a battle code
- Views all generated images and prompts
- Votes for favorite images (if enabled)
- Cannot submit prompts

## Core Features

### Authentication and User Management
- Simple display name-based authentication (no account creation required)
- Session persistence for battle duration
- Role assignment and management
- Online status indicators

### Battle Creation and Configuration
- Battle creation interface for hosts
- Configurable settings:
  - Battle name and description
  - Number of rounds
  - Time limits for prompt submission and voting
  - Maximum participants
  - Voting configuration (spectator voting on/off)
  - Manual or automatic winner selection
- Generation of unique battle codes for participants
- OpenAI API key input and validation (stored only in host's frontend)

### Battle Participation
- Join screen with battle code input
- Role selection (contestant/spectator)
- Waiting room for participants
- Real-time participant list with status indicators

### Prompt Submission and Image Generation
- Display of current round topic (generated by OpenAI GPT)
- Prompt input interface with character limit
- Countdown timer for submissions
- Direct integration with OpenAI's DALL-E from host's frontend for image generation
- Real-time status updates on generation progress
- Error handling for failed generations

### Voting System
- Gallery view of all generated images
- Voting interface for spectators (and contestants if enabled)
- Prevention of self-voting
- Real-time vote tallying
- Voting countdown timer

### Results Display
- Round results with vote counts
- Cumulative scoreboard across rounds
- Winner announcements with visual highlights
- Final battle results and rankings

### Host Controls
- Battle management dashboard
- Round start/end controls
- Participant management
- Manual winner selection option
- Timer overrides
- Settings adjustments mid-battle

## Technical Architecture

### Frontend Structure
- React with TypeScript for component development
- Vite for fast builds and development
- Responsive design principles for cross-device compatibility
- Component hierarchy organized by feature
- State management using React Context or Redux
- Real-time updates via Firebase SDK

### Backend Integration
- Firebase Realtime Database for live data synchronization
- Firebase Authentication for session management
- Firebase Security Rules for access control
- Firebase Hosting for deployment (optional)

### OpenAI API Integration
- API key management handled entirely in host's frontend
- GPT integration for topic generation
- DALL-E integration for image generation
- Rate limiting and error handling

## Firebase Realtime Database Schema

```json
{
  "battles": {
    "$battleId": {
      "metadata": {
        "name": "String",
        "description": "String",
        "createdAt": "Timestamp",
        "hostId": "String",
        "battleCode": "String",
        "status": "String", // "waiting", "active", "completed", "cancelled"
        "settings": {
          "numRounds": "Number",
          "promptTimeLimit": "Number",
          "votingTimeLimit": "Number",
          "maxContestants": "Number",
          "spectatorVotingEnabled": "Boolean",
          "manualWinnerSelection": "Boolean",
          "useCustomTopics": "Boolean",
          "customTopics": ["String"]
        }
      },
      "participants": {
        "$userId": {
          "displayName": "String",
          "role": "String", // "host", "contestant", "spectator"
          "joinedAt": "Timestamp",
          "status": "String", // "online", "offline", "typing"
          "lastActive": "Timestamp",
          "score": "Number" // cumulative across rounds
        }
      },
      "rounds": {
        "$roundId": {
          "roundNumber": "Number",
          "topic": "String",
          "startedAt": "Timestamp",
          "endedAt": "Timestamp",
          "status": "String", // "waiting", "prompt_submission", "generating", "voting", "completed"
          "promptEndTime": "Timestamp",
          "votingEndTime": "Timestamp",
          "submissions": {
            "$userId": {
              "prompt": "String",
              "submittedAt": "Timestamp",
              "imageUrl": "String",
              "generationStatus": "String", // "pending", "generating", "completed", "failed"
              "error": "String"
            }
          },
          "votes": {
            "$userId": {
              "votedFor": "String", // userId of the contestant voted for
              "votedAt": "Timestamp"
            }
          },
          "results": {
            "winner": "String", // userId of the round winner
            "voteCountByUser": {
              "$userId": "Number" // count of votes received
            },
            "announcedAt": "Timestamp"
          }
        }
      },
      "messages": {
        "$messageId": {
          "sender": "String", // userId
          "content": "String",
          "sentAt": "Timestamp",
          "type": "String" // "chat", "system", "announcement"
        }
      }
    }
  },
  "users": {
    "$userId": {
      "displayName": "String",
      "lastActive": "Timestamp",
      "activeBattleId": "String", // currently joined battle
      "battlesHosted": ["String"], // array of battleIds
      "battlesJoined": ["String"]  // array of battleIds
    }
  },
  "activeBattles": {
    "$battleCode": {
      "battleId": "String",
      "name": "String",
      "hostName": "String",
      "status": "String",
      "participantCount": "Number",
      "createdAt": "Timestamp"
    }
  }
}
```

## User Interface Requirements

### Landing Page
- Clear options to create or join a battle
- Information about what a Prompt Battle is
- Responsive design for all devices
- Simple authentication with display name entry

### Host Interface
- Dashboard with battle controls
- Participant management
- Round management
- Settings configuration
- Results display
- API key management (stored only in frontend)

### Contestant Interface
- Round information display
- Prompt submission form
- Timer indicators
- Gallery view of all images
- Voting interface (if enabled)
- Results view

### Spectator Interface
- Gallery view of images
- Voting interface
- Results view
- Participant list

## Security Considerations

### API Key Protection
- Host's OpenAI API key is stored only in their frontend application
- No backend server required for API key handling
- Rate limiting implemented in frontend to prevent excessive usage

### Data Validation
- Validate all user inputs on both client and server
- Sanitize prompts for inappropriate content
- Check image content for policy violations

### Access Control
- Implement Firebase Security Rules to restrict access
- Prevent unauthorized access to battles
- Enforce role-based permissions

## Open Source License Recommendation

Based on the requirements and the nature of the application, the MIT License is recommended for this project. The MIT License:

- Is short and permissive, allowing users to do almost anything with the code
- Requires only attribution to original authors
- Is widely used in the React ecosystem
- Allows for maximum adoption and collaboration
- Permits both open-source and commercial use of the software

This license aligns well with the collaborative and creative nature of prompt battles while providing basic protections for the original authors.

## Implementation Guidelines for AI Development

For optimal AI-assisted development in Cursor with Claude 3.7 Sonnet, we recommend:

### Code Organization
- Organize the project into feature-based modules
- Separate UI components from business logic
- Use TypeScript interfaces for all data structures
- Implement custom hooks for Firebase and OpenAI integration

### Database Optimization
- Don't listen at the database root level
- Use query-based rules to limit downloads
- Structure data in a flat, efficient manner
- Optimize connections for better performance

### State Management
- Implement React Context for global state
- Use reducers for complex state transitions
- Consider Firebase's real-time nature in state design
- Cache results where appropriate

### Responsive Design
- Implement a mobile-first approach
- Use CSS modules or styled components
- Define breakpoints for different device sizes
- Ensure touch-friendly UI elements

## User Flows

### Host Flow
1. Enter display name on landing page
2. Create a new battle
3. Configure battle settings
4. Input OpenAI API key (stored only in frontend)
5. Share battle code with participants
6. Wait for participants to join
7. Start first round
8. Monitor prompt submissions
9. Initiate image generation using their API key
10. Start voting phase
11. End round and display results
12. Repeat for subsequent rounds
13. End battle and show final results

### Contestant Flow
1. Enter display name on landing page
2. Join a battle with code
3. Select contestant role
4. Wait for host to start round
5. View current topic
6. Submit prompt before timer ends
7. Wait for image generation
8. View all generated images
9. Vote for favorite (if enabled)
10. View round results
11. Repeat for subsequent rounds
12. View final battle results

### Spectator Flow
1. Enter display name on landing page
2. Join a battle with code
3. Select spectator role
4. Observe prompt submissions
5. View generated images
6. Vote for favorite image
7. View round results
8. Repeat for subsequent rounds
9. View final battle results

## Conclusion

This comprehensive specification document provides all the necessary details to implement "The Prompt Battle" application using React, Vite, TypeScript, and Firebase Realtime Database. The document is structured to facilitate AI-assisted development with Cursor and Claude 3.7 Sonnet, providing clear requirements, database schema, user flows, and implementation guidelines.

By following these specifications, developers can create an engaging platform for hosting Prompt Battles that works seamlessly across devices and provides an intuitive experience for hosts, contestants, and spectators alike.